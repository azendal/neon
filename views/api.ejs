<h1><i class="icon icon-gears api-icon"></i> API</h1>

<h3 id="api.instatiation">Class and Module instantiation</h3>

<%= Cd.printCode( function(){ %>
```javascript
Class([namespace], [className]) // => Factory
Module([namespace], [className]) // => Factory

```
<% }) %>

<p>The optional namespace argument is a valid javascript object of which the
created class will be a property, if no namespace is passed, it will be the
global object.</p>

<p>The className argument is a string with the name of the class. It's possible
to not pass a className, in which case the class will have an autogenerated
name, this is common for creating anonymous classes. Note that you cannot
have an anonymous class inside a namespace, the first argument will be
interpreted as the className.</p>

<h3 id="api.definition">Class and Module definition</h3>

<%= Cd.printCode( function(){ %>
```javascript
factory({
    staticProperties...,
    prototype : {
        instanceProperties...
    }
}); // => Class

```
<% }) %>

<p>The class factory is an executable property, which accepts the class definition
as a parameter.</p>

<p>The objects' properties will be copied by reference as static properties to the
class.</p>

<p>The <code>prototype</code> property of the class definition will serve as the base
prorotype for the created objects. In fact, this is the
<a rel="noreferrer" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/prototype">standard prototype</a>
of Javascript. The properties in it will be copied by reference to all created
objects.</p>

<h3 id="api.initialization">Class initialization</h3>

<%= Cd.printCode( function(){ %>
```javascript
init : function( ... )

```
<% }) %>

<p>When instantiating classes, they will call the <code>init</code> method defined in them, if
overriden (It doesn't do anything by default).</p>

<p>To create an instance of an object, use the standard Javascript object
constructor <code>new</code>. The parameters are passed to the init function</p>

<%= Cd.printCode( function(){ %>
```javascript
var x = new MyClass()

```
<% }) %>

<h3 id="api.initialization">Class properties</h3>

<%= Cd.printCode( function(){ %>
```javascript
MyClass.className // => Returns the name of the class
MyClass.superClass // => Returns the actual parent class
myInstance.constructor // => Returns a reference to the object's class

```
<% }) %>

<h3 id="api.initialization">Caveats</h3>

<p>Be aware that since javascript's prototype works by reference, all non primitive
values will point to the parent's prototype. To avoid this, make sure you assign
a new value to those properties after initialization</p>

<h2 id="api.initialization">What it doesn't do</h2>

<h6> <p><code>super</code> calls</p> </h6>
<p>The reasoning behind not including the <code>super</code> functionality is that it requires
introspection. Even though it's possible, the library tries not to mess with the
Javascript way of doing things. If you need to call the same method of a parent
class, you can use the function property of the prototype and call it yourself,
e.g.</p>

<%= Cd.printCode( function(){ %>
```javascript
myMethod : function(params) {
    ParentClass.prototype.myMethod.call(this, params);
}

```
<% }) %>

<h6> <p><code>private</code> scoping</p> </h6>
<p>When working in pure Javascript or using the Node module system, it's easy to hide
functions by keeping them as a inner closures and not adding them to the
prototype of the class. Neon does not have this functionality, since the classes
are just wrapped objects and javascript does not have a way to hide properties
However, the suggested convention is to name your private methods with an
underscore as the first character (e.g. _myMethod) to indicate that the method
is private.</p>
