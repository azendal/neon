<h1><i class="icon icon-gears api-icon"></i> API</h1>

<h3 id="api.instatiation">Class and Module instantiation</h3>

<%= Cd.printCode( function(){ %>
```javascript
Class([namespace], [className]) // => Factory
Module([namespace], [className]) // => Factory

```
<% }) %>

<p>The optional namespace argument is a valid javascript object of which the
created class will be a property, or the global context by default.</p>

<p>The className argument is a string with the name of the class. It is possible
to not pass a className, in which case the class will have an autogenerated
name, this is common for creating anonymous classes. Note that you cannot
have an anonymous class inside a namespace, the first argument will be
interpreted as the className.</p>

<h3 id="api.definition">Class and Module definition</h3>

<%= Cd.printCode( function(){ %>
```javascript
factory({
    staticProperties...,
    prototype : {
        instanceProperties...
    }
}); // => Class

```
<% }) %>

<p>The class factory is an executable property, which accepts the class definition
as a parameter.</p>

<p>The object properties will be copied by reference as static properties to the
class.</p>

<p>The <code>prototype</code> property of the class definition will serve as the base
prorotype of the created objects. In fact, this is the
<a rel="noreferrer" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/prototype">standard prototype</a>
of Javascript. The properties in it will be copied by reference to all created
objects.</p>

<h3 id="api.initialization">Class initialization</h3>

<%= Cd.printCode( function(){ %>
```javascript
init : function( ... )

```
<% }) %>

<p>When instantiating classes, they will call the <code>init</code> method defined in them, if
overriden (By default it does nothing).</p>

<p>To create an instance of an object, use the standard Javascript object
constructor <code>new</code>. The parameters are passed to the init function</p>

<%= Cd.printCode( function(){ %>
```javascript
var x = new MyClass()

```
<% }) %>

<h3 id="api.initialization">Class properties</h3>

<%= Cd.printCode( function(){ %>
```javascript
MyClass.className // => Returns the name of the class
MyClass.superClass // => Returns the actual parent class
myInstance.constructor // => Returns a reference to the object's class

```
<% }) %>

<h3 id="api.initialization">Caveats</h3>

<p>Be aware that since javascript's prototype works by reference, all non primitive
values will point to the parent's prototype. To avoid this, make sure you assign
a new value to those properties after initialization</p>

<h2 id="api.initialization">What does not do</h2>

<h6> <p><code>super</code> calls</p> </h6> 
<p>The reasoning behind not including the <code>super</code> functionality is that it requires
introspection. Even though is possible, the library tries to not mess with the
Javascript way of doing things. If you need to call the same method of a parent
class, you can use the function property of the prototype and call it yourself,
e.g.</p>

<%= Cd.printCode( function(){ %>
```javascript
myMethod : function(params) {
    ParentClass.prorotype.myMethod.call(this, params);
}

```
<% }) %>

<h6> <p><code>private</code> scoping</p> </h6> 
<p>When working in pure Javascript or using Node module system, it is easy to hide
functions by keeping them as a inner closure and not adding them to the
prototype of the class. Neon does not have this functionality, since the classes
are just wrapped objects and javascript does not have a way to hide properties
itself. However, the suggested convention is to name your private methods
starting with an underscore (_myMethod) to indicate that the method is private.</p>