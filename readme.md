<article data-task-list-update-url="/chubas/d07c4e305cfb57987edd/file/gistfile1.md" class="markdown-body js-file ">
        <h1>
<a href="#neon" class="anchor" name="neon"><span class="mini-icon mini-icon-link"></span></a>NEON</h1>

<h2>
<a href="#what-is-it" class="anchor" name="what-is-it"><span class="mini-icon mini-icon-link"></span></a>What is it?</h2>

<p>Neon is a javascript Class system, designed to wrap up object oriented logic
around Javascript objects (which are not truly OO), and to establish a common
base language for developers using such classes.</p>

<h2>
<a href="#quick-usage-example" class="anchor" name="quick-usage-example"><span class="mini-icon mini-icon-link"></span></a>Quick Usage Example</h2>

<pre><code>Module('Draggable')({
    threshold : 10,
    prototype : {
        isDragging : false,
        startDrag : function() { ... }
    }
});

Class(UI, 'Widget')({
    HTML : '&lt;div&gt;&lt;/div&gt;',
    prototype : {
        init : function() { ... },
        render : function() { ... }
    }
});

Class(UI, 'Overlay').inherits(UI.Widget).includes(Draggable)({
    HTML : '&lt;div class="overlay"&gt;&lt;/div&gt;',
    prototype : {
        color : 'white',
        init : function() { ... },
        close : function() { ... }
    }
});

UI.Overlay.threshold // =&gt; 10
UI.Overlay.HTML // =&gt; '&lt;div class="overlay"&gt;&lt;/div&gt;'
var overlay = new UI.Overlay({ color : 'black' });
overlay.color; // =&gt; 'black'
overlay.render();
overlay.close();
</code></pre>

<h2>
<a href="#what-does-it-offer" class="anchor" name="what-does-it-offer"><span class="mini-icon mini-icon-link"></span></a>What does it offer</h2>

<ul>
<li>
<p>Convenient DSL for creating classes</p>

<p>The syntax for creating the classes is very similar with that of those OO
languages.</p>
</li>
<li>
<p>Inheritance</p>

<p>Inheritance is pretty much the reason to use OO, so it provides a nice way of
subclassing. In esence, it's about extending javascript objects with the
properties of the base class.</p>
</li>
<li>
<p>Modules (composition)</p>

<p>You can include modules or mixins to your classes. You can extend multiple
modules to a single class.</p>
</li>
</ul><h2>
<a href="#api" class="anchor" name="api"><span class="mini-icon mini-icon-link"></span></a>API</h2>

<h3>
<a href="#class-and-module-instantiation" class="anchor" name="class-and-module-instantiation"><span class="mini-icon mini-icon-link"></span></a>Class and Module instantiation</h3>

<pre><code>Class([namespace], [className]) // =&gt; Factory
Module([namespace], [className]) // =&gt; Factory
</code></pre>

<p>The optional namespace argument is a valid javascript object of which the
created class will be a property, or the global context by default.</p>

<p>The className argument is a string with the name of the class. It is possible
to not pass a className, in which case the class will have an autogenerated
name, this is common for creating anonymous classes. Note that you cannot
have an anonymous class inside a namespace, the first argument will be
interpreted as the className.</p>

<h3>
<a href="#class-and-module-definition" class="anchor" name="class-and-module-definition"><span class="mini-icon mini-icon-link"></span></a>Class and Module definition</h3>

<pre><code>factory({
    staticProperties...,
    prototype : {
        instanceProperties...
    }
}); // =&gt; Class
</code></pre>

<p>The class factory is an executable property, which accepts the class definition
as a parameter.</p>

<p>The object properties will be copied by reference as static properties to the
class.</p>

<p>The <code>prototype</code> property of the class definition will serve as the base
prorotype of the created objects. In fact, this is the
<a rel="noreferrer" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/prototype">standard prototype</a>
of Javascript. The properties in it will be copied by reference to all created
objects.</p>

<h3>
<a href="#class-initialization" class="anchor" name="class-initialization"><span class="mini-icon mini-icon-link"></span></a>Class initialization</h3>

<pre><code>init : function( ... )
</code></pre>

<p>When instantiating classes, they will call the <code>init</code> method defined in them, if
overriden (By default it does nothing).</p>

<p>To create an instance of an object, use the standard Javascript object
constructor <code>new</code>. The parameters are passed to the init function</p>

<pre><code>var x = new MyClass()
</code></pre>

<h3>
<a href="#class-properties" class="anchor" name="class-properties"><span class="mini-icon mini-icon-link"></span></a>Class properties</h3>

<pre><code>MyClass.className // =&gt; Returns the name of the class
MyClass.superClass // =&gt; Returns the actual parent class
myInstance.constructor // =&gt; Returns a reference to the object's class
</code></pre>

<h3>
<a href="#caveats" class="anchor" name="caveats"><span class="mini-icon mini-icon-link"></span></a>Caveats</h3>

<p>Be aware that since javascript's prototype works by reference, all non primitive
values will point to the parent's prototype. To avoid this, make sure you assign
a new value to those properties after initialization</p>

<h2>
<a href="#what-does-not-do" class="anchor" name="what-does-not-do"><span class="mini-icon mini-icon-link"></span></a>What does not do</h2>

<ul>
<li>
<code>super</code> calls</li>
</ul><p>The reasoning behind not including the <code>super</code> functionality is that it requires
introspection. Even though is possible, the library tries to not mess with the
Javascript way of doing things. If you need to call the same method of a parent
class, you can use the function property of the prototype and call it yourself,
e.g.</p>

<pre><code>myMethod : function(params) {
    ParentClass.prorotype.myMethod.call(this, params);
}
</code></pre>

<ul>
<li>Private scoping</li>
</ul><p>When working in pure Javascript or using Node module system, it is easy to hide
functions by keeping them as a inner closure and not adding them to the
prototype of the class. Neon does not have this functionality, since the classes
are just wrapped objects and javascript does not have a way to hide properties
itself. However, the suggested convention is to name your private methods
starting with an underscore (_myMethod) to indicate that the method is private.</p>

<h2>
<a href="#final-notes" class="anchor" name="final-notes"><span class="mini-icon mini-icon-link"></span></a>Final notes</h2>

<h3>
<a href="#so-why-another-class-library-system" class="anchor" name="so-why-another-class-library-system"><span class="mini-icon mini-icon-link"></span></a>So, why another Class library system?</h3>

<p>Well, first of all, Neon was created around the time most of these libraries
were still being developed, so it is natural that many of them appeared
simultaneously (especially after the explosion on Node usage)
But more importantly, Neon was created in order to make frontend coding more
accesible to backend developers, who already know OO languages such as Ruby or
PHP, as well as creating a common language in which they could communicate.
Neon does not try to emulate other language, and preserves the Javascript good
parts, with a nicer syntax.</p>
      </article>










# NEON

## What is it?

Neon is a javascript Class system, designed to wrap up object oriented logic
around Javascript objects (which are not truly OO), and to establish a common
base language for developers using such classes.

## Quick Usage Example

    Module('Draggable')({
        threshold : 10,
        prototype : {
            isDragging : false,
            startDrag : function() { ... }
        }
    });

    Class(UI, 'Widget')({
        HTML : '<div></div>',
        prototype : {
            init : function() { ... },
            render : function() { ... }
        }
    });

    Class(UI, 'Overlay').inherits(UI.Widget).includes(Draggable)({
        HTML : '<div class="overlay"></div>',
        prototype : {
            color : 'white',
            init : function() { ... },
            close : function() { ... }
        }
    });

    UI.Overlay.threshold // => 10
    UI.Overlay.HTML // => '<div class="overlay"></div>'
    var overlay = new UI.Overlay({ color : 'black' });
    overlay.color; // => 'black'
    overlay.render();
    overlay.close();

## What does it offer

* Convenient DSL for creating classes
  
  The syntax for creating the classes is very similar with that of those OO
languages.

* Inheritance

  Inheritance is pretty much the reason to use OO, so it provides a nice way of
subclassing. In esence, it's about extending javascript objects with the
properties of the base class.

* Modules (composition)

  You can include modules or mixins to your classes. You can extend multiple
modules to a single class.

## API

### Class and Module instantiation

    Class([namespace], [className]) // => Factory
    Module([namespace], [className]) // => Factory

The optional namespace argument is a valid javascript object of which the
created class will be a property, or the global context by default.

The className argument is a string with the name of the class. It is possible
to not pass a className, in which case the class will have an autogenerated
name, this is common for creating anonymous classes. Note that you cannot
have an anonymous class inside a namespace, the first argument will be
interpreted as the className.

### Class and Module definition

    factory({
        staticProperties...,
        prototype : {
            instanceProperties...
        }
    }); // => Class

The class factory is an executable property, which accepts the class definition
as a parameter.

The object properties will be copied by reference as static properties to the
class.

The `prototype` property of the class definition will serve as the base
prorotype of the created objects. In fact, this is the
[standard prototype](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/prototype)
of Javascript. The properties in it will be copied by reference to all created
objects.

### Class initialization

    init : function( ... )

When instantiating classes, they will call the `init` method defined in them, if
overriden (By default it does nothing).

To create an instance of an object, use the standard Javascript object
constructor `new`. The parameters are passed to the init function

    var x = new MyClass()

### Class properties

    MyClass.className // => Returns the name of the class
    MyClass.superClass // => Returns the actual parent class
    myInstance.constructor // => Returns a reference to the object's class


### Caveats

Be aware that since javascript's prototype works by reference, all non primitive
values will point to the parent's prototype. To avoid this, make sure you assign
a new value to those properties after initialization

## What does not do

* `super` calls

The reasoning behind not including the `super` functionality is that it requires
introspection. Even though is possible, the library tries to not mess with the
Javascript way of doing things. If you need to call the same method of a parent
class, you can use the function property of the prototype and call it yourself,
e.g.

    myMethod : function(params) {
        ParentClass.prorotype.myMethod.call(this, params);
    }

* Private scoping

When working in pure Javascript or using Node module system, it is easy to hide
functions by keeping them as a inner closure and not adding them to the
prototype of the class. Neon does not have this functionality, since the classes
are just wrapped objects and javascript does not have a way to hide properties
itself. However, the suggested convention is to name your private methods
starting with an underscore (_myMethod) to indicate that the method is private.

## Final notes

### So, why another Class library system?

Well, first of all, Neon was created around the time most of these libraries
were still being developed, so it is natural that many of them appeared
simultaneously (especially after the explosion on Node usage)
But more importantly, Neon was created in order to make frontend coding more
accesible to backend developers, who already know OO languages such as Ruby or
PHP, as well as creating a common language in which they could communicate.
Neon does not try to emulate other language, and preserves the Javascript good
parts, with a nicer syntax.

